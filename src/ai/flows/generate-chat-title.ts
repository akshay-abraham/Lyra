/**
 * @fileoverview Flow to Generate a Chat Title (`generate-chat-title.ts`)
 *
 * C-like Analogy:
 * This is a small, specialized utility function. Its only job is to take the first
 * message of a new chat and create a short, descriptive title for it (e.g.,
 * "Solving for x in Algebra").
 *
 * This is useful for displaying a list of past conversations in the chat history sidebar.
 *
 * The primary exported function is `generateChatTitle`.
 */
'use server';


// Import necessary libraries.
// C-like analogy: #include <genkit_lib.h> and #include <zod_struct_lib.h>
import {ai} from '@/ai/genkit';
import {z} from 'genkit';

/**
 * C-like Analogy: Input Struct Definition
 *
 * typedef struct {
 *     char* firstMessage; // The first message sent by the user in a new chat.
 * } GenerateChatTitleInput;
 */
const GenerateChatTitleInputSchema = z.object({
  firstMessage: z.string().describe('The first message from the user in a chat session.'),
});
// Create a TypeScript "type" from the schema.
export type GenerateChatTitleInput = z.infer<typeof GenerateChatTitleInputSchema>;


/**
 * C-like Analogy: Output Struct Definition
 *
 * typedef struct {
 *     char* title; // The short title generated by the AI.
 * } GenerateChatTitleOutput;
 */
const GenerateChatTitleOutputSchema = z.object({
  title: z.string().describe('A short, descriptive title for the chat session (5 words max).'),
});
// Create a TypeScript "type" from the schema.
export type GenerateChatTitleOutput = z.infer<typeof GenerateChatTitleOutputSchema>;


/**
 * C-like Analogy: `GenerateChatTitleOutput* generateChatTitle(GenerateChatTitleInput* input)`
 *
 * This is the main exported function that our application UI will call when a new
 * chat is started.
 */
export async function generateChatTitle(input: GenerateChatTitleInput): Promise<GenerateChatTitleOutput> {
  // It's a simple wrapper that calls the internal Genkit flow.
  return generateChatTitleFlow(input);
}


/**
 * C-like Analogy: The AI Prompt Template (like a `printf` format string)
 *
 * This defines the instructions we send to the AI. It's very simple: we give it
 * the user's first message and ask it to generate a short title.
 *
 * The `{{{firstMessage}}}` part is where the actual message text is inserted.
 */
const prompt = ai.definePrompt({
  name: 'generateChatTitlePrompt',
  input: {schema: GenerateChatTitleInputSchema},   // Input data format.
  output: {schema: GenerateChatTitleOutputSchema}, // Expected output format.
  prompt: `Based on the following user message, generate a short, descriptive title for the chat session (max 5 words).

User Message: {{{firstMessage}}}

Title:`,
});


/**
 * C-like Analogy: The Core Logic Function
 *
 * This defines the Genkit "flow", the managed server-side function that does the work.
 */
const generateChatTitleFlow = ai.defineFlow(
  {
    name: 'generateChatTitleFlow',
    inputSchema: GenerateChatTitleInputSchema,
    outputSchema: GenerateChatTitleOutputSchema,
  },
  // This is the function body of the flow.
  async input => {
    // PSEUDOCODE:
    // 1. Call the AI with our prompt, filling in the `input` data.
    //    `result = ai_call(prompt, input);`
    //    This is an asynchronous call, so we `await` its completion.
    const {output} = await prompt(input);

    // 2. The `result.output` is guaranteed by Genkit to match our `GenerateChatTitleOutputSchema`.
    //    We can simply return it. The `!` tells TypeScript we are sure it's not null.
    return output!;
  }
);
