// Copyright (C) 2025 Akshay K Rooben Abraham
/**
 * @fileoverview Generates an AI Tutor Response (`generate-ai-tutor-response.ts`).
 * @copyright Copyright (C) 2025 Akshay K Rooben Abraham. All rights reserved.
 *
 * @description
 * This file contains the core logic for the application: generating a helpful,
 * Socratic-style response to a student's problem. It defines the data structures
 * for the input (problem statement, custom prompts) and output (tutor response),
 * the prompt template given to the AI, and the main Genkit flow that orchestrates
 * the process.
 *
 * C-like Analogy:
 * This is a primary function module, like `tutor_logic.c`. It exposes a single
 * main function, `generateAITutorResponse`, which takes a student's problem and
 * optional configuration, and returns the AI's generated response. It encapsulates
 * all the details of interacting with the AI model for this specific task.
 */
'use server';

// Import necessary libraries.
// C-like analogy: #include <genkit_lib.h> and #include <zod_struct_lib.h>
import { ai } from '@/ai/genkit';
import { z } from 'genkit';
import type { Message, ChatSession } from '@/types';

/**
 * @typedef {object} GenerateAITutorResponseInput
 * @description The input schema for the main AI tutor response generation flow.
 *
 * C-like Analogy:
 * This is the `struct` definition for the function's input parameters.
 *
 * ```c
 * typedef struct {
 *     char* problemStatement;        // The student's question.
 *     char* systemPrompt;            // (Optional) Custom rules from the teacher.
 *     char** exampleGoodAnswers;    // (Optional) An array of good answer examples for few-shot learning.
 * } GenerateAITutorResponseInput;
 * ```
 * @property {string} problemStatement - The problem statement from the student.
 * @property {string} [systemPrompt] - The system prompt to guide the AI tutor.
 * @property {string[]} [exampleGoodAnswers] - Examples of good answers to guide the AI.
 */
const GenerateAITutorResponseInputSchema = z.object({
  problemStatement: z
    .string()
    .describe('The problem statement from the student.'),
  systemPrompt: z
    .string()
    .optional()
    .describe('The system prompt to guide the AI tutor.'),
  exampleGoodAnswers: z
    .array(z.string())
    .optional()
    .describe('Examples of good answers to guide the AI.'),
});
// Create a TypeScript "type" from the schema.
export type GenerateAITutorResponseInput = z.infer<
  typeof GenerateAITutorResponseInputSchema
>;

/**
 * @typedef {object} GenerateAITutorResponseOutput
 * @description The output schema for the main AI tutor response generation flow.
 *
 * C-like Analogy:
 * This is the `struct` for the function's return value.
 *
 * ```c
 * typedef struct {
 *     char* tutorResponse; // The final response generated by the AI tutor.
 * } GenerateAITutorResponseOutput;
 * ```
 * @property {string} tutorResponse - The AI tutor response, providing hints, analogies, and questions.
 */
const GenerateAITutorResponseOutputSchema = z.object({
  tutorResponse: z
    .string()
    .describe(
      'The AI tutor response, providing hints, analogies, and questions.',
    ),
});
// Create a TypeScript "type" from the schema.
export type GenerateAITutorResponseOutput = z.infer<
  typeof GenerateAITutorResponseOutputSchema
>;

/**
 * The main exported function that our application UI will call. It's a clean
 * wrapper around the internal Genkit flow, abstracting away the implementation details.
 *
 * @param {GenerateAITutorResponseInput} input - The input data, matching the schema.
 * @returns {Promise<GenerateAITutorResponseOutput>} A promise that resolves with the AI's generated output.
 *
 * C-like Analogy:
 * ```c
 * // The public API function declared in `tutor_logic.h`.
 * GenerateAITutorResponseOutput* generateAITutorResponse(GenerateAITutorResponseInput* input);
 * ```
 */
export async function generateAITutorResponse(
  input: GenerateAITutorResponseInput,
): Promise<GenerateAITutorResponseOutput> {
  // It simply calls the internal flow function and returns whatever it returns.
  return generateAITutorResponseFlow(input);
}

/**
 * This defines the AI prompt template. It's a structured set of instructions
 * that gets sent to the AI model, combining a system message, few-shot examples,
 * and the user's query. The syntax is Handlebars, which allows for conditional
 * logic and data insertion.
 *
 * C-like Analogy:
 * This is like a powerful `sprintf` format string combined with `if-else` blocks
 * and `for` loops, used to construct the final text prompt for the AI.
 *
 * - `{{#if systemPrompt}} ... {{else}} ... {{/if}}`: This is an if-else block. If the teacher
 *   provided a custom `systemPrompt`, we use it. Otherwise, we use the default Lyra prompt.
 * - `{{#if exampleGoodAnswers}} ... {{/each}} {{/if}}`: This is a for loop. If there are
 *   example answers, we loop through them and list them for the AI to learn from.
 * - `{{{problemStatement}}}`: This is where the student's actual question is inserted.
 */
const prompt = ai.definePrompt({
  name: 'generateAITutorResponsePrompt',
  input: { schema: GenerateAITutorResponseInputSchema }, // Links to the input struct.
  output: { schema: GenerateAITutorResponseOutputSchema }, // Tells the AI the output struct format.
  prompt: `{{#if systemPrompt}} {{systemPrompt}} {{else}} You are Lyra, an AI tutor. Your goal is to help the student verbalize their problem and guide them towards the solution by providing hints, analogies, and questions instead of direct answers. You should never give the direct answer. Emulate the Socratic method. Be patient and encouraging. You can use Markdown for formatting, including MermaidJS for diagrams (using \`\`\`mermaid code blocks). {{/if}}\n\n{{#if exampleGoodAnswers}} Here are some examples of good answers: {{#each exampleGoodAnswers}} - {{{this}}} {{/each}} {{/if}}\n\nProblem Statement: {{{problemStatement}}}`,
});

/**
 * This is the core logic function, defining the Genkit "flow".
 * A flow is a managed, server-side function that can be logged, traced, and monitored.
 *
 * @param {object} config - The flow's configuration.
 * @param {string} config.name - A unique name for this flow.
 * @param {z.ZodSchema} config.inputSchema - The expected input data structure.
 * @param {z.ZodSchema} config.outputSchema - The expected output data structure.
 * @param {function(GenerateAITutorResponseInput): Promise<GenerateAITutorResponseOutput>} flowFunction - The async function that performs the work.
 */
const generateAITutorResponseFlow = ai.defineFlow(
  {
    name: 'generateAITutorResponseFlow',
    inputSchema: GenerateAITutorResponseInputSchema,
    outputSchema: GenerateAITutorResponseOutputSchema,
  },
  // This is the function body of the flow.
  async (input) => {
    // PSEUDOCODE:
    // 1. Call the AI prompt template, filling it in with the `input` data.
    //    `result = ai_call(prompt, input);`
    //    This is an asynchronous call, so we `await` its completion.
    const { output } = await prompt(input);

    // 2. The `result.output` will automatically be in the format of our
    //    `GenerateAITutorResponseOutput` struct because we defined it in the prompt.
    //    We can just return it directly. The `!` is a TypeScript thing that means
    //    "I'm sure this value is not null".
    return output!;
  },
);
